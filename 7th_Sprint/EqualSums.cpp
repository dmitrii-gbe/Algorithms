/*
https://contest.yandex.ru/contest/25597/run-report/117915313/
-- ПРИНЦИП РАБОТЫ --
Решение принимает входные данные с помощью функции GetNumbers и хранит их в виде массива. Ответ вычисляется в
функции IfPossibleToSplit. Сначала проверяется что массив содержит более одного элемента и что их общая сумма
кратна 2. Затем, если массив удовлетворяет этим условиям, функция проверяет, можно ли из данного набора
элементов набрать целевую сумму. Механизм подсчета аналогичен реализации задачи о рюкзаке. В случае, если
набрать эту сумму удается, функция возвращает true, в противном случае - false.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Очевидно, что чтобы разделить массив чисел на две части с равными суммами, в массиве должно быть больше одного
элемента, а их сумма должна быть кратна 2. Проверка того, можно ли набрать из массива числа с определенной
суммой базируется на решении задачи о рюкзаке. Рассмотрим набор элементов (чисел) от 0 до i-го и сумму S.
Нужно выбрать такой набор чисел, чтобы получить сумму, равную S. Набрать S с использованием элементов от 0 до
i возможно в двух случаях:
1. Можно набрать S, не используя i-ый элемент. Тогда i-ый в набор не входит.
2. Можно набрать сумму S минус значение i-ого элемента, используя набор элементов от 0 до i-1.
Таким образом, решение можно представить как последовательное (слева
направо и сверху вниз) вычисление значений матрицы, где столбцы соответствуют верхнему ограничению на
максимальную сумму элементов, а строки набору элементов от нуля до i.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Временая сложность алгоритма составляет O(MN), где M - половина общей суммы элементов, а N - общее число
элементов в массиве.

-- Пространственная сложность --
Пространственная сложность алгоритма составляет O(M), где M - где M - половина суммы элементов в массиве.
Поскольку восстановление ответа не требуется вместо полной матрицы хранятся только две строки, необходимые для
вычисления в текущий момент.
*/

#include <iostream>
#include <numeric>
#include <vector>

std::vector<int> GetNumbers(int number) {
    std::vector<int> numbers(number, 0);
    for (int i = 0; i != number; ++i) {
        std::cin >> numbers[i];
    }
    return numbers;
}

bool IfPossibleToSplit(const std::vector<int>& numbers) {
    int max_sum = std::reduce(numbers.begin(), numbers.end(), 0, std::plus{});
    if (numbers.size() < 2 || max_sum % 2 != 0) {
        return false;
    }

    int half_sum = max_sum / 2;

    std::vector<bool> active(half_sum + 1, false);
    active[0] = true;
    std::vector<bool> buffer = active;

    for (int i = 1; i < (int)numbers.size() + 1; ++i) {
        for (int sum = 1; sum < half_sum + 1; ++sum) {
            active[sum] = (sum >= numbers[i - 1] ? buffer[sum - numbers[i - 1]] : false) || buffer[sum];
        }
        std::swap(active, buffer);
    }

    return buffer.back();
}

int main() {
    int numbers_count = 0;

    std::cin >> numbers_count;

    auto numbers = GetNumbers(numbers_count);

    std::cout << (IfPossibleToSplit(numbers) ? "True" : "False");

    return 0;
}

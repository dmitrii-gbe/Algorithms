// https://contest.yandex.ru/contest/25597/run-report/117915432/
/*
-- ПРИНЦИП РАБОТЫ --
Решение принимает входные данные с помощью функции GetString, после чего вычисляет редакционное расстояние
между ними в функции CalculateDistance. Механизм ее работы можно представить себе как вычисление минимальных
редакционных расстояний между всеми префиксами первой и второй строк. Внутри функции создаются два массива
целых чисел, из которых bufer предназначен для хранения уже рассчитанных расстояний между префиксом
фиксированной длины N одной из строк и всеми префиксами второй строки. Во втором массиве active сохраняются
результаты текущих рассчетов, для которых испоьзуется информация из bufer. При этом имеется ввиду, что
минимальное расстояние между непустым префиксом и пустой строкой (0-ой префикс) равно длине непустого
префикса. Этот факт учитывается с помощью функции AssignValues, которая обрабатывает возможные пограничные
ситуации и присваивает значения элементам, расположенным в воображаемой матрице сверху, слева и сверху-слева
(по диагонали) от вычисляемого. По оканчании вычисления элементов массива active, содержимое active и bufer
обменивается. Таким образом, порядок вычисления эквивалентем вычислению элементов матрицы слева-сверху
направо-вниз с тем отличием, что хранится не вся матрица, а только две строки.

Вычисление значения в текущей ячейке:
Значению в ячейке с индексами i и j придается смысл минимального расстояния между префиксами длиной i - 1 и j
- 1 (длина в исходных строках, тогда как в рассчетах используются еще нулевые префиксы). В случае, если
последние символы текущих префиксов совпали, в ячейку копируется диагональный элемент слева-сверху,
обозначающий минимальное расстояние между префиксами короче текущих на один символ. Если символы не совпали,
то в ячейку записывается минимальный из левого, верхнего и диагонального элементов, к которому прибавляется
единица. Первые два случая соответствуют удалению/добавлению символа, а последний - замене.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Предположим, что мы располагаемся в какой-либо ячейке матрицы минимальных расстояний между префиксами двух
строк, причем все расстояния слева и сверху от ячейки уже известны. Тогда, если символы, соответствующие
индексам вычисляемой ячейки равны, то искомая величина будет равна расстоянию между двумя префиксами короче на
один  символ. В противном случае, минимальное расстояние между префиксами будет минимумумом между левой,
верхней и диагональной ячеек, к которому прибавляется единица как штраф за текущее отличие. Если значение
берется сверху или слева, это соответствует добавлению/удалению символа в/из одной(у) из строк. Использование
диагональной ячейки означает замену символа в одной из строк. Таким образом, для подсчета нужно достаточно
знать только значения сверху и слева от текущей ячейки и вся матрица может быть заполнена из левого верхнего
угла в правый нижний сначала по строкам, затем по столбцам.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Временная сложность работы алгоритма - О(MN), где M и N - длины первой и второй строк.

-- Пространственная сложность --
В текущей реализации алгоритм требует О(M + N), где M и N - длины строк. одной из двух строк.
*/
#include <iostream>
#include <numeric>
#include <vector>

std::string GetString() {
    std::string result;
    std::getline(std::cin, result);
    return result;
}

int CalculateDistance(const std::string& s1, const std::string& s2) {
    std::vector<int> active(s2.size() + 1);
    std::vector<int> bufer(s2.size() + 1);
    std::iota(bufer.begin(), bufer.end(), 0);
    for (size_t i = 1; i < s1.size() + 1; ++i) {
        active[0] = i;
        for (size_t j = 1; j < s2.size() + 1; ++j) {
            int left = active[j - 1];
            int top = bufer[j];
            int diag = bufer[j - 1];

            if (s1[i - 1] == s2[j - 1]) {
                active[j] = diag;
            } else {
                active[j] = std::min(left, std::min(top, diag)) + 1;
            }
        }
        std::swap(bufer, active);
    }

    return bufer.back();
}

int main() {
    auto seq1 = GetString();

    auto seq2 = GetString();

    std::cout << CalculateDistance(seq1, seq2);

    return 0;
}
